#include <stdio.h>
#include <stdlib.h>

// Reduce the size of Windows.h to improve compile time
#define WIN32_LEAN_AND_MEAN
#define NOCOMM
#define NOCLIPBOARD
#define NODRAWTEXT
#define NOMB
#include <Windows.h>
#include <sys/stat.h>

#include <sph_sha3.h>
#include <sph_md5.h>

#include "remote_injection.h"
#include "../hash/hashes.h"

int main(int argc, char** argv)
{
    // Turn relative paths into full paths
    char full_path[MAX_PATH] = { 0 };
    GetFullPathNameA("pdpm.dll", MAX_PATH, full_path, NULL);

    // Kill Phantom Dust if it's already running
    uint32_t process_id = get_pid_by_name("PDUWP.exe");
    if (process_id != 0) {
        // Get a handle with permission to terminate the game
        void* process = OpenProcess(PROCESS_TERMINATE, false, process_id);
        if (process == NULL) {
            printf("main(): Unable to open process ID %d for termination.\n", process_id);
            return false;
        }
        // Terminate Phantom Dust with an exit code of 0
        TerminateProcess(process, 0);
    }

    // DLL hashes generated by "hash.cmake" at build time.
    static const char sha512_string[] = {
        #include "../hash/pdpm.sha512"
    };
    static const char md5_string[] = {
        #include "../hash/pdpm.md5"
    };

    // Turn hex string hashes into binary data for comparison
    static uint64_t sha512_hash[8] = {0};
    static uint64_t md5_hash[2] = {0};
    hash_string_to_hash((uint8_t*) sha512_string, (uint8_t*) &sha512_hash);
    hash_string_to_hash((uint8_t*) md5_string, (uint8_t*) &md5_hash);

    // Get the DLL's size and read it into memory to be hashed
    struct stat st;
    stat(full_path, &st);
    uint32_t filesize = st.st_size;

    uint8_t* data = calloc(1, filesize + 1);
    FILE* dll_file = fopen(full_path, "rb");
    fread(data, filesize, 1, dll_file);
    fclose(dll_file);

    // Buffers to hold the SHA-512 and MD5 hashes
    uint64_t sha512_buffer[8] = {0};
    uint64_t md5_buffer[2] = {0};

    // Calculate the SHA-512 and MD5 hashes, then write them into the buffers above
    sph_sha512_context sha512_context;
    sph_sha512_init(&sha512_context);
    sph_sha512(&sha512_context, data, filesize);
    sph_sha512_close(&sha512_context, &sha512_buffer);

    sph_md5_context md5_context;
    sph_md5_init(&md5_context);
    sph_md5(&md5_context, data, filesize);
    sph_md5_close(&md5_context, &md5_buffer);

    // Free DLL file from memory
    free(data);

    bool sha_512_match = false;
    for (uint8_t i = 0; i < 8; i++) {
        sha_512_match = (sha512_buffer[i] == sha512_hash[i]);
        if (!sha_512_match) {
            break;
        }
    }

    bool md5_match = (md5_buffer[0] == md5_hash[0] && md5_buffer[1] == md5_hash[1]);

    // Run Phantom Dust
    system("explorer shell:AppsFolder\\Microsoft.MSEsper_8wekyb3d8bbwe!App");
    while (get_pid_by_name("PDUWP.exe") == 0) {
        Sleep(1);
    }

    // Both hashes must match to proceed with injection
    if (!sha_512_match || !md5_match) {
        return 1;
    }

    process_id = get_pid_by_name("PDUWP.exe");

	if(!dll_inject_remote(process_id, full_path, MAX_PATH + 1)) {
		printf("Injecting mods into Phantom Dust... Failed.\n");
		system("pause");
		return EXIT_FAILURE;
	}
	printf("Injecting mods into Phantom Dust... Success!\n");

	return EXIT_SUCCESS;
}
